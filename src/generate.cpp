#include <string>
#include <unordered_map>

#include "constgen.h"

namespace constgen {

void upper_snake(std::string &str)
{
    for (auto &c : str) {
        switch (c) {
        case '/':
        case '.':
        case '-':
            c = '_';
            break;

        default:
            c = (char) toupper(c);
            break;
        }
    }
}

#define MAKE_GUARD(schema, ext) std::string guard = schema.source.stem().string() + ext; upper_snake(guard);

void c_header_generate(const Schema &schema, std::ostream &outs)
{
    bool as_enum = (
        (schema.type == TYPE_ENUM && !schema.enum_schema.as_preproc)
            || (schema.type == TYPE_ALIAS && !schema.alias_schema.as_preproc)
    );

    MAKE_GUARD(schema, ".h");

    outs << "/*\n"
            " * THIS FILE WAS GENERATED BY constgen\n"
            " *          DO NOT MODIFY\n"
            " * ORIGIN FILE: " << schema.source << "\n"
            " */\n"
         << std::endl;
    outs << "#ifndef " << guard << std::endl;
    outs << "#define " << guard << std::endl << std::endl;

    if (as_enum) {
        outs << "enum " << schema.name << " {" << std::endl;
    }
}

void c_body_generate(const Schema &schema, std::ostream &outs)
{
    int i = 0;

    switch (schema.type) {
    case TYPE_ENUM:
        for (auto &value : schema.enum_schema.values) {
            if (schema.enum_schema.overrides.contains(value)) {
                i = schema.enum_schema.overrides.at(value);
            }

            if (schema.enum_schema.as_preproc) {
                outs << "#define " << value << " " << i << std::endl;
            } else {
                outs << "    " << value << " = " << i << "," << std::endl;
            }

            i++;
        }

        break;

    case TYPE_BITFLAG:
        outs << "#define " << schema.bitflag_schema.values[0] << " 0" << std::endl;
        for (size_t j = 1; j < schema.bitflag_schema.values.size(); j++) {
            auto &value = schema.bitflag_schema.values[j];
            outs << "#define " << value << " (1 << " << i << ")" << std::endl;
            i++;
        }

        for (auto &composite: schema.bitflag_schema.composites) {
            char sep;
            switch (composite.second.op) {
            case OR:    sep = '|'; break;
            }

            outs << "#define " << composite.first << " (" << composite.second.components[0];
            for (size_t j = 1; j < composite.second.components.size(); j++) {
                outs << sep << composite.second.components[j];
            }
            outs << ")" << std::endl;
        }

        break;

    case TYPE_ALIAS:
        for (auto &entry: schema.alias_schema.values) {
            if (schema.alias_schema.as_preproc) {
                outs << "#define " << entry.first << " " << entry.second << std::endl;
            } else {
                outs << "    " << entry.first << " = " << entry.second << "," << std::endl;
            }
        }

        break;
    }
}

void c_footer_generate(const Schema &schema, std::ostream &outs)
{
    bool as_enum = (
        (schema.type == TYPE_ENUM && !schema.enum_schema.as_preproc)
            || (schema.type == TYPE_ALIAS && !schema.alias_schema.as_preproc)
    );

    MAKE_GUARD(schema, ".h");

    if (as_enum) {
        outs << "};" << std::endl;
    }

    outs << std::endl << "#endif // " << guard << std::endl;
}

void asm_header_generate(const Schema &schema, std::ostream &outs)
{
    MAKE_GUARD(schema, ".inc");

    outs << "; THIS FILE WAS GENERATED BY constgen\n"
            ";          DO NOT MODIFY\n"
            "; ORIGIN FILE: " << schema.source << "\n"
         << std::endl;

    outs << "    .ifndef " << guard << std::endl;
    outs << "    .set " << guard << ", 1" << std::endl << std::endl;
}

void asm_body_generate(const Schema &schema, std::ostream &outs)
{
    int i = 0;

    switch (schema.type) {
    case TYPE_ENUM:
        for (auto &value : schema.enum_schema.values) {
            if (schema.enum_schema.overrides.contains(value)) {
                i = schema.enum_schema.overrides.at(value);
            }

            outs << "    .equ " << value << ", " << i << std::endl;
            i++;
        }

        break;

    case TYPE_BITFLAG:
        outs << "    .equ " << schema.bitflag_schema.values[0] << ", 0" << std::endl;
        for (size_t j = 1; j < schema.bitflag_schema.values.size(); j++) {
            auto &value = schema.bitflag_schema.values[j];
            outs << "    .equ " << value << ", (1 << " << i << ")" << std::endl;
            i++;
        }

        for (auto &composite: schema.bitflag_schema.composites) {
            char sep;
            switch (composite.second.op) {
            case OR:    sep = '|'; break;
            }

            outs << "    .equ " << composite.first << ", (" << composite.second.components[0];
            for (size_t j = 1; j < composite.second.components.size(); j++) {
                outs << sep << composite.second.components[j];
            }
            outs << ")" << std::endl;
        }

        break;

    case TYPE_ALIAS:
        for (auto &entry: schema.alias_schema.values) {
            outs << "    .equ " << entry.first << ", " << entry.second << std::endl;
        }

        break;
    }
}

void asm_footer_generate(const Schema &schema, std::ostream &outs)
{
    MAKE_GUARD(schema, ".inc");

    outs << std::endl << "    .endif ; " << guard << std::endl;
}

typedef void (*HeaderGenFunc)(const Schema &schema, std::ostream &outs);
typedef void (*BodyGenFunc)(const Schema &schema, std::ostream &outs);
typedef void (*FooterGenFunc)(const Schema &schema, std::ostream &outs);

struct FunctionSet {
    HeaderGenFunc header_gen;
    BodyGenFunc body_gen;
    FooterGenFunc footer_gen;
};

static std::unordered_map<Language, FunctionSet> LANG_FUNC_MAP = {
    { LANGUAGE_C,   { c_header_generate,   c_body_generate,   c_footer_generate   } },
    { LANGUAGE_ASM, { asm_header_generate, asm_body_generate, asm_footer_generate } },
    { LANGUAGE_PY,  { } },
};

}; // constgen

void constgen::generate(const Schema &schema, const Language lang, std::ostream &outs)
{
    FunctionSet gen_funcs = LANG_FUNC_MAP[lang];
    gen_funcs.header_gen(schema, outs);
    gen_funcs.body_gen(schema, outs);
    gen_funcs.footer_gen(schema, outs);
}

