#include <string>
#include <unordered_map>

#include "constgen.h"

namespace constgen {

void upper_snake(std::string &str)
{
    for (auto &c : str) {
        switch (c) {
        case '/':
        case '.':
        case '-':
            c = '_';
            break;

        default:
            c = (char) toupper(c);
            break;
        }
    }
}

#define MAKE_GUARD(schema, ext) std::string guard = schema.source.stem().string() + ext; upper_snake(guard);

void header_generate(const Schema &schema, std::ostream &outs, std::string comment_prefix, std::string guard)
{
    outs << comment_prefix << "THIS FILE WAS GENERATED BY constgen\n"
         << comment_prefix << "         DO NOT MODIFY\n"
         << comment_prefix << "ORIGIN FILE: " << schema.source << "\n"
         << "\n"
         << guard << "\n"
         << std::endl;
}

void body_generate(const Schema &schema, std::ostream &outs, std::string prefix, std::string midfix, std::string postfix)
{
    int i = 0;

    switch (schema.type) {
    case TYPE_ENUM:
        for (auto &value : schema.enum_schema.values) {
            if (schema.enum_schema.overrides.contains(value)) {
                i = schema.enum_schema.overrides.at(value);
            }

            outs << prefix << value << midfix << i << postfix << std::endl;
            i++;
        }

        break;

    case TYPE_BITFLAG:
        outs << prefix << schema.bitflag_schema.values[0] << midfix << 0 << postfix << std::endl;
        for (size_t j = 1; j < schema.bitflag_schema.values.size(); j++) {
            auto &value = schema.bitflag_schema.values[j];
            outs << prefix << value << midfix << "(1 << " << i << ")" << postfix << std::endl;
            i++;
        }

        for (auto &composite : schema.bitflag_schema.composites) {
            char sep;
            switch (composite.second.op) {
            case OR:    sep = '|'; break;
            }

            outs << prefix << composite.first << midfix << "(" << composite.second.components[0];
            for (size_t j = 1; j < composite.second.components.size(); j++) {
                outs << sep << composite.second.components[j];
            }
            outs << ")" << postfix << std::endl;
        }

        break;
    case TYPE_ALIAS:
        for (auto &entry: schema.alias_schema.values) {
            outs << prefix << entry.first << midfix << entry.second << postfix << std::endl;
        }

        break;
    }
}

void c_header_generate(const Schema &schema, std::ostream &outs)
{
    MAKE_GUARD(schema, ".h");
    std::string full_guard = "#ifndef " + guard + "\n"
                           + "#define " + guard + "\n";
    header_generate(schema, outs, " * ", full_guard);

    bool as_enum = (
        (schema.type == TYPE_ENUM && !schema.enum_schema.as_preproc)
            || (schema.type == TYPE_ALIAS && !schema.alias_schema.as_preproc)
    );

    if (as_enum) {
        outs << "enum " << schema.name << " {" << std::endl;
    }
}

void c_body_generate(const Schema &schema, std::ostream &outs)
{
    std::string prefix = "#define";
    std::string midfix = " ";
    std::string postfix = "";

    bool as_enum = (
        (schema.type == TYPE_ENUM && !schema.enum_schema.as_preproc)
            || (schema.type == TYPE_ALIAS && !schema.alias_schema.as_preproc)
    );

    if (as_enum) {
        prefix = "    ";
        midfix = " = ";
        postfix = ",";
    }

    body_generate(schema, outs, prefix, midfix, postfix);
}

void c_footer_generate(const Schema &schema, std::ostream &outs)
{
    bool as_enum = (
        (schema.type == TYPE_ENUM && !schema.enum_schema.as_preproc)
            || (schema.type == TYPE_ALIAS && !schema.alias_schema.as_preproc)
    );

    MAKE_GUARD(schema, ".h");

    if (as_enum) {
        outs << "};" << std::endl;
    }

    outs << std::endl << "#endif // " << guard << std::endl;
}

void asm_header_generate(const Schema &schema, std::ostream &outs)
{
    MAKE_GUARD(schema, ".inc");
    std::string full_guard = "    .ifndef " + guard + "\n"
                           + "    .set " + guard + ", 1\n";
    header_generate(schema, outs, "; ", full_guard);
}

void asm_body_generate(const Schema &schema, std::ostream &outs)
{
    body_generate(schema, outs, "    .equ ", ", ", "");
}

void asm_footer_generate(const Schema &schema, std::ostream &outs)
{
    MAKE_GUARD(schema, ".inc");
    outs << std::endl << "    .endif ; " << guard << std::endl;
}

void py_header_generate(const Schema &schema, std::ostream &outs)
{
    std::string base_enum = "enum.Enum";
    if (schema.type == TYPE_BITFLAG) {
        base_enum = "enum.Flag";
    }

    std::string full_guard = "import enum\n"
                             "class " + schema.name + "(" + base_enum + "):\n";
    header_generate(schema, outs, "# ", full_guard);
}

void py_body_generate(const Schema &schema, std::ostream &outs)
{
    body_generate(schema, outs, "    ", " = ", "");
}

void py_footer_generate(const Schema &schema, std::ostream &outs)
{
    return;
}

typedef void (*HeaderGenFunc)(const Schema &schema, std::ostream &outs);
typedef void (*BodyGenFunc)(const Schema &schema, std::ostream &outs);
typedef void (*FooterGenFunc)(const Schema &schema, std::ostream &outs);

struct FunctionSet {
    HeaderGenFunc header_gen;
    BodyGenFunc body_gen;
    FooterGenFunc footer_gen;
};

static std::unordered_map<Language, FunctionSet> LANG_FUNC_MAP = {
    { LANGUAGE_C,   { c_header_generate,   c_body_generate,   c_footer_generate   } },
    { LANGUAGE_ASM, { asm_header_generate, asm_body_generate, asm_footer_generate } },
    { LANGUAGE_PY,  { py_header_generate,  py_body_generate,  py_footer_generate  } },
};

}; // constgen

void constgen::generate(const Schema &schema, const Language lang, std::ostream &outs)
{
    FunctionSet gen_funcs = LANG_FUNC_MAP[lang];
    gen_funcs.header_gen(schema, outs);
    gen_funcs.body_gen(schema, outs);
    gen_funcs.footer_gen(schema, outs);
}

